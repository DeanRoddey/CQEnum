// This file was auto-generated by CQEnum.exe, do not edit
#include <cstdint>
#include <stdexcept>
#include <ostream>
#include "Test.hpp"

namespace CQSL { namespace Test {  namespace {

enum class ETypes { Arbitrary, Bitmap, Standard };

struct EnumTableVal
{
    const wchar_t* const   pszName;
    int64_t                iOrdinal;
    int32_t                iAltVal;
    const wchar_t* const   pszText1;
    const wchar_t* const   pszText2;
};

const wchar_t* const pszOrdinalToAltText(const  EnumTableVal* const paTable
                                        , const uint32_t            uCount
                                        , const int64_t             iFind
                                        , const uint32_t            uWhichText)
{
    for (uint32_t uIndex = 0; uIndex < uCount; uIndex++)
    {
        if (paTable[uIndex].iOrdinal == iFind)
        {
            return (uWhichText == 1) ? paTable[uIndex].pszText1 : paTable[uIndex].pszText2;
        }
        if (paTable[uIndex].iOrdinal > iFind)
        {
            break;
        }
    }
    return nullptr;
}

uint32_t uOrdinalToIndex(  const   EnumTableVal* const paTable
                           , const uint32_t            uCount
                           , const int64_t             iFind)
{
    for (uint32_t uIndex = 0; uIndex < uCount; uIndex++)
    {
        if (paTable[uIndex].iOrdinal == iFind)
        {
            return uIndex;
        }
        if (paTable[uIndex].iOrdinal > iFind)
        {
            break;
        }
    }
    return std::numeric_limits<uint32_t>::max();
}

uint32_t uAltValToIndex(const  EnumTableVal* const paTable
                       , const uint32_t            uCount
                       , const int32_t             iFind)
{
    for (uint32_t uIndex = 0; uIndex < uCount; uIndex++)
    {
        if (paTable[uIndex].iAltVal == iFind)
        {
            return uIndex;
        }
    }
    return std::numeric_limits<uint32_t>::max();
}

uint32_t uNameToIndex( const   EnumTableVal* const paTable
                       , const uint32_t            uCount
                       , const std::wstring_view&  svFind)
{
    for (uint32_t uIndex = 0; uIndex < uCount; uIndex++)
    {
        if (_wcsicmp(svFind.data(), paTable[uIndex].pszName) == 0)
        {
            return uIndex;
        }
    }
    return std::numeric_limits<uint32_t>::max();
}



struct
{
    ETypes         eType;
    EnumTableVal   aevalTable[3];
} EnumTable_TestEnum =
{
    ETypes::Standard,
    {
        { L"Value1", 0, 0, L"The text for value 1", L"The text2 for value 1" }
      , { L"Value2", 1, 0, L"The text for value 2", L"The text2 for value 2" }
      , { L"Value3", 2, 0, L"The text for value 3", L"The text2 for value 3" }

    }
};

struct
{
    ETypes         eType;
    EnumTableVal   aevalTable[3];
} EnumTable_TestBmp =
{
    ETypes::Bitmap,
    {
        { L"Value1", 1, 101, L"The text for value 1", L"The text2 for value 1" }
      , { L"Value2", 2, 102, L"The text for value 2", L"The text2 for value 2" }
      , { L"Value3", 4, 103, L"The text for value 3", L"The text2 for value 3" }

    }
};


} // Anonymous namespace


// External constants
const std::wstring strTest = L"The value of the string object";


// Enumeration method implementations
bool bNameToEnum(const std::wstring_view& svName, CQSL::Test::TestEnum& eToFill)
{
    const uint32_t uIndex = uNameToIndex(EnumTable_TestEnum.aevalTable, 3, svName);
    if (uIndex >= 3)
    {
        return false;
    }
    eToFill = static_cast<CQSL::Test::TestEnum>(EnumTable_TestEnum.aevalTable[uIndex].iOrdinal);
    return true;
}
const wchar_t* pszEnumToName(const CQSL::Test::TestEnum eVal)
{
    const uint32_t uIndex = uOrdinalToIndex(EnumTable_TestEnum.aevalTable, 3, static_cast<int64_t>(eVal));
    if (uIndex >= 3)
    {
        return nullptr;
    }
    return EnumTable_TestEnum.aevalTable[uIndex].pszName;
}
const wchar_t* pszEnumToAltText1(const CQSL::Test::TestEnum eVal)
{    
    uint32_t uIndex = 0;
    if ((eVal < CQSL::Test::TestEnum::Min) || (eVal > CQSL::Test::TestEnum::Max))
    {
        throw std::runtime_error("Invalid value for 'CQSL::Test::TestEnum' enumeration");
    }
    uIndex = static_cast<uint32_t>(eVal);
    return EnumTable_TestEnum.aevalTable[uIndex].pszText1;
}

const wchar_t* pszEnumToAltText2(const CQSL::Test::TestEnum eVal)
{    
    uint32_t uIndex = 0;
    if ((eVal < CQSL::Test::TestEnum::Min) || (eVal > CQSL::Test::TestEnum::Max))
    {
        throw std::runtime_error("Invalid value for 'CQSL::Test::TestEnum' enumeration");
    }
    uIndex = static_cast<uint32_t>(eVal);
    return EnumTable_TestEnum.aevalTable[uIndex].pszText2;
}

bool bNameToEnum(const std::wstring_view& svName, CQSL::Test::TestBmp& eToFill)
{
    const uint32_t uIndex = uNameToIndex(EnumTable_TestBmp.aevalTable, 3, svName);
    if (uIndex >= 3)
    {
        return false;
    }
    eToFill = static_cast<CQSL::Test::TestBmp>(EnumTable_TestBmp.aevalTable[uIndex].iOrdinal);
    return true;
}
const wchar_t* pszEnumToName(const CQSL::Test::TestBmp eVal)
{
    const uint32_t uIndex = uOrdinalToIndex(EnumTable_TestBmp.aevalTable, 3, static_cast<int64_t>(eVal));
    if (uIndex >= 3)
    {
        return nullptr;
    }
    return EnumTable_TestBmp.aevalTable[uIndex].pszName;
}
bool bIsValidEnumVal(const CQSL::Test::TestBmp eTest)
{
    const uint32_t uIndex = uOrdinalToIndex(EnumTable_TestBmp.aevalTable, 3, static_cast<int64_t>(eTest));
    return (uIndex < 3);
}
const wchar_t* pszEnumToAltText1(const CQSL::Test::TestBmp eVal)
{    
    uint32_t uIndex = 0;
    uIndex = uOrdinalToIndex(EnumTable_TestBmp.aevalTable, 3, static_cast<int64_t>(eVal));
    if (uIndex >= 3)
    {
        throw std::runtime_error("Invalid value for 'CQSL::Test::TestBmp' enumeration");
    }
    return EnumTable_TestBmp.aevalTable[uIndex].pszText1;
}

const wchar_t* pszEnumToAltText2(const CQSL::Test::TestBmp eVal)
{    
    uint32_t uIndex = 0;
    uIndex = uOrdinalToIndex(EnumTable_TestBmp.aevalTable, 3, static_cast<int64_t>(eVal));
    if (uIndex >= 3)
    {
        throw std::runtime_error("Invalid value for 'CQSL::Test::TestBmp' enumeration");
    }
    return EnumTable_TestBmp.aevalTable[uIndex].pszText2;
}

bool bEnumToAltValue(const CQSL::Test::TestBmp eVal, int32_t& iToFill)
{
    const uint32_t uIndex = uOrdinalToIndex(EnumTable_TestBmp.aevalTable, 3, static_cast<int64_t>(eVal));
    if (uIndex >= 3)
    {
        return false;
    }
    iToFill = EnumTable_TestBmp.aevalTable[uIndex].iAltVal;
    return true;
}
bool bEnumFromAltValue(const int32_t iAltVal, CQSL::Test::TestBmp& eToFill)
{
    const uint32_t uIndex = uAltValToIndex(EnumTable_TestBmp.aevalTable, 3, iAltVal);
    if (uIndex >= 3)
    {
        return false;
    }
    eToFill = static_cast<CQSL::Test::TestBmp>(EnumTable_TestBmp.aevalTable[uIndex].iOrdinal);
    return true;
}

}};


