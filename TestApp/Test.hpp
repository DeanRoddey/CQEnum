// This file was auto-generated by Spidl.exe, do not edit

namespace CQSL { namespace Test { 

    constexpr unsigned int uTest = 10;
    static const wchar_t* pszTest = L"The value of the raw string";
    extern std::wstring strTest;


    enum class TestEnum : int32_t
    {
          Value1 = 0
        , Value2 = 1
        , Value3 = 2
        , Min = 0
        , Max = 2
        , Count = 3
        , Syn1 = 0
    };
    const wchar_t* pszEnumToAltText1(const CQSL::Test::TestEnum eVal);
    const wchar_t* pszEnumToAltText2(const CQSL::Test::TestEnum eVal);
    const wchar_t* pszEnumToName(const CQSL::Test::TestEnum eVal);
    bool bNameToEnum(const wchar_t* const pszText, CQSL::Test::TestEnum& eToFill);
    inline bool bNameToEnum(const std::wstring& strText, CQSL::Test::TestEnum& eToFill)
    {
        return bNameToEnum(strText.c_str(), eToFill);
    }
    inline bool bIsValidEnumVal(const CQSL::Test::TestEnum eTest)
    {
        return ((eTest >= CQSL::Test::TestEnum::Min) && (eTest <= CQSL::Test::TestEnum::Max));
    }


    enum class TestBmp : int16_t
    {
          Value1 = 1
        , Value2 = 2
        , Value3 = 4
        , AllBits = 0x7
        , Syn1 = 4
    };
    const wchar_t* pszEnumToAltText1(const CQSL::Test::TestBmp eVal);
    const wchar_t* pszEnumToAltText2(const CQSL::Test::TestBmp eVal);
    bool bEnumToAltValue(const CQSL::Test::TestBmp eVal, int32_t& iToFill);
    bool bEnumFromAltValue(const int32_t iAltVal, CQSL::Test::TestBmp& eToFill);
    const wchar_t* pszEnumToName(const CQSL::Test::TestBmp eVal);
    bool bNameToEnum(const wchar_t* const pszText, CQSL::Test::TestBmp& eToFill);
    inline bool bNameToEnum(const std::wstring& strText, CQSL::Test::TestBmp& eToFill)
    {
        return bNameToEnum(strText.c_str(), eToFill);
    }
    bool bIsValidEnumVal(const CQSL::Test::TestBmp eTest);
    inline bool bAllEnumBitsOn(const CQSL::Test::TestBmp eTest, const CQSL::Test::TestBmp eBits)
    {
        return (static_cast<int16_t>(eTest) & static_cast<int16_t>(eBits)) == static_cast<int16_t>(eBits);
    }
    inline bool bAnyEnumBitsOn(const CQSL::Test::TestBmp eTest, const CQSL::Test::TestBmp eBits)
    {
        return (static_cast<int16_t>(eTest) & static_cast<int16_t>(eBits)) != 0;
    }

}};


inline CQSL::Test::TestEnum& operator++(CQSL::Test::TestEnum& eVal)
{
    if (eVal < CQSL::Test::TestEnum::Count)
    {
        eVal = static_cast<CQSL::Test::TestEnum>(static_cast<int32_t>(eVal) + 1);
    }
    return eVal;
}
inline CQSL::Test::TestEnum operator++(CQSL::Test::TestEnum& eVal, int)
{
    const CQSL::Test::TestEnum eRet = eVal;
    if (eVal < CQSL::Test::TestEnum::Count)
    {
        eVal = static_cast<CQSL::Test::TestEnum>(static_cast<int32_t>(eVal) + 1);
    }
    return eRet;
}


constexpr CQSL::Test::TestBmp operator|(const CQSL::Test::TestBmp eLHS, const CQSL::Test::TestBmp eRHS)
{
    return static_cast<CQSL::Test::TestBmp>(static_cast<int16_t>(eLHS) | static_cast<int16_t>(eRHS));
}
constexpr CQSL::Test::TestBmp operator&(const CQSL::Test::TestBmp eLHS, const CQSL::Test::TestBmp eRHS)
{
    return static_cast<CQSL::Test::TestBmp>(static_cast<int16_t>(eLHS) & static_cast<int16_t>(eRHS));
}
constexpr CQSL::Test::TestBmp operator|=(CQSL::Test::TestBmp& eLHS, const CQSL::Test::TestBmp eRHS)
{
    eLHS = static_cast<CQSL::Test::TestBmp>(static_cast<int16_t>(eLHS) | static_cast<int16_t>(eRHS));
    return eLHS;
}
constexpr CQSL::Test::TestBmp operator&=(CQSL::Test::TestBmp& eLHS, const CQSL::Test::TestBmp eRHS)
{
    eLHS = static_cast<CQSL::Test::TestBmp>(static_cast<int16_t>(eLHS) & static_cast<int16_t>(eRHS));
    return eLHS;
}
constexpr CQSL::Test::TestBmp operator~(const CQSL::Test::TestBmp eTurnOff)
{
    return static_cast<CQSL::Test::TestBmp>(static_cast<int16_t>(CQSL::Test::TestBmp::AllBits) & ~static_cast<int16_t>(eTurnOff));
}


